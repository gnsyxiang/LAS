data-operation
==============

## 减少运算的强度

### 查表(游戏程序猿必修课)

一个聪明的游戏大虾，基本上不会在自己的主循环里搞什么运算工作，
绝对是先计算好了，再到循环里查表。
如果表很大，不好写，就写一个init函数，在循环外临时生成表格。

```c
long factorial(int i)
{
    if (i == 0)
        return 1;
    else
        return i * factorial(i - 1);

}

===>

static long factorial_table[] = {1， 1， 2， 6， 24， 120， 720};
long factorial(int i)
{
    return factorial_table[i];
}
```

### 求余运算

```c
a %= 8;    ===> a &= 7;
```

说明：位操作只需一个指令周期即可完成，
而大部分的C编译器的“%”运算均是调用子程序来完成，代码长、执行速度慢。
通常，只要求是求2n方的余数，均可使用位操作的方法来代替。

### 平方运算

```c
a = pow(a, 2, 0);   ===>  a = a * a;
a = pow(a, 3, 0);   ===>  a = a * a * a;
```
说明: 在有内置硬件乘法器中，乘法运算比平方运算快的多，
因为浮点数的求平方是通过调用子程序来实现的，在自带硬件乘法器的AVR单片机中，
如ATMega163中，乘法运算只需2个时钟周期就可以完成。
既使是在没有内置硬件乘法器的AVR单片机中，
乘法运算的子程序比平方运算的子程序代码短，执行速度快。

### 用移位实现乘除法运算

```c
a *= 4;  ===> a <<= 2;
b /= 4;  ===> b >>= 2
c *= 9;  ===> c = (c << 3) + c;
```

说明: 通常如果需要乘以或除以2n，都可以用移位的方法代替。

```c
x = w % 8;
y = pow(x, 2.0)
z = y * 33;

for (i = 0; i < MAX; i++) {
    h = 14 * i;
    printf("%d\n", h);
}

===>
x = w & 7;                  //位操作比求余运算快
y = x * x;                  //乘法比平方运算快
z = (y << 5) + y;           //位移乘法比乘法快

for (i = 0; i < MAX; i++) {
    h += 14;                //加法比乘法快
    printf("%d\n", h);
}
```

### 避免不必要的整数除法

整数除法是整数运算中最慢的，所以应该尽可能避免。
一种可能减少整数除法的地方是连除，这里除法可以由乘法代替。
这个替换的`副作用`是有可能在算乘积时会溢出，所以只能在一定范围的除法中使用。

```c
int i,j,k,m;
m = i / j / k；

===>
int i,j,k,m;
m = i / (j * k);
```

### 使用增量和减量操作符

在使用到加一和减一操作时尽量使用增量和减量操作符，因为增量符语句比赋值语句更快，
原因在于对大多数CPU来说，对内存字的增、减量操作不必明显地使用取内存和写内存的指令。

```c
x = x + 1;

产生的汇编语言大致如下:
move A，x       ;把x从内存取出存入累加器A
add A，1        ;累加器A加1
store x         ;把新值存回x

如果使用增量操作符，生成的代码如下：
incr x          ;x加1
```
说明: 不用取指令和存指令，增、减量操作执行的速度加快，同时长度也缩短了。

### 使用复合赋值表达式
复合赋值表达式(如a-=1及a+=1等)都能够生成高质量的程序代码。


### 提取公共的子表达式

在某些情况下，C++编译器不能从浮点表达式中提出公共的子表达式，
因为这意味着相当于对表达式重新排序。需要特别指出的是，
编译器在提取公共子表达式前不能按照代数的等价关系重新安排表达式。
这时，程序员要手动地提出公共的子表达式。

```c
float a, b, c, d, e, f;

e = b * c / d;
f = b / d * a;

===>

float a, b, c, d, e, f;

const float t(b / d);
e = c * t;
f = a * t;
```

```c
float a, b, c, d, e, f;

e = a / c;
f = b / c;

===>

float a, b, c, d, e, f;

const float t(1.0f / c);
e = a * t;
f = b * t;
```

## 提高CPU的并行性

### 使用并行代码

尽可能把长的有依赖的代码链分解成几个可以在流水线执行单元中并行执行的没有依赖的代码链。
很多高级语言，包括C++，并不对产生的浮点表达式重新排序，因为那是一个相当复杂的过程。
需要注意的是，重排序的代码和原来的代码在代码上一致并不等价于计算结果一致，
因为浮点操作缺乏精确度。在一些情况下，这些优化可能导致意料之外的结果。幸运的是，
在大部分情况下，最后结果可能只有最不重要的位（即最低位）是错误的。

```c
double a[100], sum,
int i;
sum = 0.0f;
for (i=0; i<100; i++)
    sum += a[i];

===>

double a[100], sum1, sum2, sum3, sum4, sum;
int i;
sum1 = sum2 = sum3 = sum4 = 0.0;
for (i = 0; i < 100; i += 4)
{
    　　sum1 += a[i];
    　　sum2 += a[i+1];
    　　sum3 += a[i+2];
    　　sum4 += a[i+3];

}
sum = (sum4+sum3)+(sum1+sum2);
```

要注意的是：使用4 路分解是因为这样使用了4段流水线浮点加法，
浮点加法的每一个段占用一个时钟周期，保证了最大的资源利用率。

### 避免没有必要的读写依赖

i当数据保存到内存时存在读写依赖，即数据必须在正确写入后才能再次读取。虽然AMD Athlon等CPU有加速读写依赖延迟的硬件，允许在要保存的数据被写入内存前读取出来，但是，如果避免了读写依赖并把数据保存在内部寄存器中，速度会更快。在一段很长的又互相依赖的代码链中，避免读写依赖显得尤其重要。如果读写依赖发生在操作数组时，许多编译器不能自动优化代码以避免读写依赖。所以推荐程序员手动去消除读写依赖，举例来说，引进一个可以保存在寄存器中的临时变量。这样可以有很大的性能提升。下面一段代码是一个例子：

```c
不好的代码：
float x[VECLEN], y[VECLEN], z[VECLEN];
。。。。。。
for (unsigned int k = 1; k < VECLEN; k ++)
{
    　　x[k] = x[k-1] + y[k];

}
for (k = 1; k <VECLEN; k++)
{
    　　x[k] = z[k] * (y[k] - x[k-1]);

}
推荐的代码：
float x[VECLEN], y[VECLEN], z[VECLEN];
。。。。。。
float t(x[0]);
for (unsigned int k = 1; k < VECLEN; k ++)
{
    　　t = t + y[k];
    　　x[k] = t;

}
t = x[0];
for (k = 1; k <; VECLEN; k ++)
{
    　　t = z[k] * (y[k] - t);
    　　x[k] = t;

} 
```






