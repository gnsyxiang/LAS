c-optimize
==========

## 数据类型

### 变量

#### register变量

在声明局部变量的时候可以使用register关键字。这就使得编译器把变量放入一个多用途的寄存器中，而不是在堆栈中，合理使用这种方法可以提高执行速度。函数调用越是频繁，越是可能提高代码的速度。
在最内层循环避免使用全局变量和静态变量，除非你能确定它在循环周期中不会动态变化，大多数编译器优化变量都只有一个办法，就是将他们置成寄存器变量，而对于动态变量，它们干脆放弃对整个表达式的优化。尽量避免把一个变量地址传递给另一个函数，虽然这个还很常用。C语言的编译器们总是先假定每一个函数的变量都是内部变量，这是由它的机制决定的，在这种情况下，它们的优化完成得最好。但是，一旦一个变量有可能被别的函数改变，这帮兄弟就再也不敢把变量放到寄存器里了，严重影响速度。看例子：
a = b();
c(&d);
因为d的地址被c函数使用，有可能被改变，编译器不敢把它长时间的放在寄存器里，一旦运行到c(&d)，编译器就把它放回内存，如果在循环里，会造成N次频繁的在内存和寄存器之间读写d的动作，众所周知，CPU在系统总线上的读写速度慢得很。比如你的赛杨300，CPU主频300，总线速度最多66M，为了一个总线读，CPU可能要等4-5个周期，得。。得。。得。。想起来都打颤。

#### 同时声明多个变量优于单独声明变量

#### 短变量名优于长变量名，应尽量使变量名短一点

#### 在循环开始前声明变量




### 使用尽量小的数据类型

* 在满足变量的表示范围下，使用顺序尽量是`char > int > long int > float`。
  必须保证不会超过变量的使用范围，C编译器并不会报错，但程序运行结果却错了，而且这样的错误很难发现。

* 在printf参数，尽量使用基本型参数(%c、%d、%x、%X、%u和%s格式说明符)，
  少用长整型参数(%ld、%lu、%lx和%lX格式说明符)，
  至于浮点型的参数(%f)则尽量不要使用，其它C编译器也一样。
  在其它条件不变的情况下，使用%f参数，会使生成的代码的数量增加很多，执行速度降低。

## 结构体成员的布局

很多编译器有“使结构体字，双字或四字对齐”的选项。但是，还是需要改善结构体成员的对齐，
有些编译器可能分配给结构体成员空间的顺序与他们声明的不同。但是，
有些编译器并不提供这些功能，或者效果不好。所以，
要在付出最少代价的情况下实现最好的结构体和结构体成员对齐，建议采取下列方法：

### 按数据类型的长度排序

把结构体的成员按照它们的类型长度排序，声明成员时把长的类型放在短的前面。
编译器要求把长型数据类型存放在偶数地址边界。
在申明一个复杂的数据类型 (既有多字节数据又有单字节数据) 时，
应该首先存放多字节数据，然后再存放单字节数据，这样可以避免内存的空洞。
编译器自动地把结构的实例对齐在内存的偶数边界。

### 把结构体填充成最长类型长度的整倍数

把结构体填充成最长类型长度的整倍数。照这样，如果结构体的第一个成员对齐了，
所有整个结构体自然也就对齐了。下面的例子演示了如何对结构体成员进行重新排序：

```c
struct {
    char a[5];
    long k;
    double x;
};

===>

struct {
    double x;
    long k;
    char a[5];
    char pad[7];
}
```
这个规则同样适用于类的成员的布局。

### 按数据类型的长度排序本地变量

当编译器分配给本地变量空间时，它们的顺序和它们在源代码中声明的顺序一样，
和上一条规则一样，应该把长的变量放在短的变量前面。
如果第一个变量对齐了，其它变量就会连续的存放，而且不用填充字节自然就会对齐。
有些编译器在分配变量时不会自动改变变量顺序，有些编译器不能产生4字节对齐的栈，
所以4字节可能不对齐。下面这个例子演示了本地变量声明的重新排序：

```c
short ga, gu, gi;
long foo, bar;
double x, y, z[3];
char a, b;
float baz;

===>

double z[3];
double x, y;
long foo, bar;
float baz;
short ga, gu, gi;
```

### 把频繁使用的指针型参数拷贝到本地变量

避免在函数中频繁使用指针型参数指向的值。因为编译器不知道指针之间是否存在冲突，
所以指针型参数往往不能被编译器优化。这样数据不能被存放在寄存器中，
而且明显地占用了内存带宽。注意，
很多编译器有“假设不冲突”优化开关（在VC里必须手动添加编译器命令行/Oa或/Ow），
这允许编译器假设两个不同的指针总是有不同的内容，
这样就不用把指针型参数保存到本地变量。
否则，请在函数一开始把指针指向的数据保存到本地变量。如果需要的话，在函数结束前拷贝回去。

```c
// 假设 q != r
void isqrt(unsigned long a， unsigned long* q， unsigned long* r)
{
    *q = a;
    if (a > 0) {
        while (*q > (*r = a / *q)) {
            *q = (*q + *r) >> 1;
        }
    }
    *r = a - *q * *q;
}

===>

// 假设 q != r
void isqrt(unsigned long a， unsigned long* q， unsigned long* r)
{
    unsigned long qq, rr;
    qq = a;
    if (a > 0) {
        while (qq > (rr = a / qq)) {
            qq = (qq + rr) >> 1;
        }
    }
    rr = a - qq * qq;
    *q = qq;
    *r = rr;
}
```


## 语法

### 数组和指针

一般来说，指针比较灵活简洁，而数组则比较直观，容易理解。
对于大部分的编译器，使用`指针运算`比使用`数组索引`生成的代码更短，执行效率更高。

下面的代码作用是相同的:

```c
for (;;) {
    a = array[t++];
    ...
}

===>
p = array;
for (;;) {
    a = *(p++);
    ...
}
```
array的地址每次装入地址p后，在每次循环中只需要对p增量操作。

在数组索引方法中，每次循环都必须根据t值计算数组下标的复杂运算。

### if结构

在if结构中如果要判断的并列条件较多，最好将它们拆分成多个if结构，
然后嵌套在一起，这样可以避免无谓的判断。

### 循环优化

#### 充分分解小的循环

要充分利用CPU的指令缓存，就要充分分解小的循环。
特别是当循环体本身很小的时候，分解循环可以提高性能。
注意:很多编译器并不能自动分解循环。

```c
// 3D转化：把矢量 V 和 4x4 矩阵 M 相乘
for (i = 0; i < 4; i++) {
    r[i] = 0;
    for (j = 0; j < 4; j ++) {
        r[i] += M[j][i]*V[j];
    }
}

===>

r[0] = M[0][0]*V[0] + M[1][0]*V[1] + M[2][0]*V[2] + M[3][0]*V[3]；
r[1] = M[0][1]*V[0] + M[1][1]*V[1] + M[2][1]*V[2] + M[3][1]*V[3]；
r[2] = M[0][2]*V[0] + M[1][2]*V[1] + M[2][2]*V[2] + M[3][2]*V[3]；
r[3] = M[0][3]*V[0] + M[1][3]*V[1] + M[2][3]*V[2] + M[3][3]*v[3]；
```

#### 提取公共部分

对于一些不需要循环变量参加运算的任务可以把它们放到循环外面，
这里的任务包括表达式、函数的调用、指针运算、数组访问等，
应该将没有必要执行多次的操作全部集合在一起，放到一个init的初始化程序中进行。

#### 延时函数

```c
void delay (void)
{
    unsigned int i;
    for (i = 0; i < 1000; i++);
}

===>

void delay (void)
{
    unsigned int i;
    for (i = 1000; i > 0; i--);
}
```

两个函数的延时效果相似，
但几乎所有的C编译对后一种函数生成的代码均比前一种代码少1~3个字节，
因为几乎所有的MCU均有为0转移的指令，采用后一种方式能够生成这类指令。
在使用while循环时也一样，使用自减指令控制循环会比使用自加指令控制循环生成的代码更少1~3个字母。
但是在循环中有通过循环变量“i”读写数组的指令时，使用预减循环有可能使数组超界，要引起注意。

#### while循环和do…while循环

```c
unsigned int i;
i=0;
while (i < 1000) {
    i++;
    //用户程序
}
或：
unsigned int i;
i = 1000;
do {
    i--;
    //用户程序
}
while (i > 0);
```
在这两种循环中，使用do…while循环编译后生成的代码的长度短于while循环。

#### 循环展开

这是经典的速度优化，但许多编译程序(如gcc -funroll-loops)能自动完成这个事，
所以现在你自己来优化这个显得效果不明显。

```c
for (i = 0; i < 100; i++) {
    do_stuff(i);
}

===>

for (i = 0; i < 100; ) {
    do_stuff(i); i++;
    do_stuff(i); i++;
    do_stuff(i); i++;
    do_stuff(i); i++;
    do_stuff(i); i++;
    do_stuff(i); i++;
    do_stuff(i); i++;
    do_stuff(i); i++;
    do_stuff(i); i++;
    do_stuff(i); i++;
}
```

可以看出，新代码里比较指令由100次降低为10次，循环时间节约了90%。
不过注意:对于中间变量或结果被更改的循环，编译程序往往拒绝展开，
(怕担责任呗)，这时候就需要你自己来做展开工作了。
还有一点请注意，在有内部指令cache的CPU上(如MMX芯片)，
因为循环展开的代码很大，往往cache溢出，
这时展开的代码会频繁地在CPU 的cache和内存之间调来调去，
又因为cache速度很高，所以此时循环展开反而会变慢。还有就是循环展开会影响矢量运算优化。

#### 循环嵌套

把相关循环放到一个循环里，也会加快速度。

```c
for (i = 0; i < MAX; i++)          /* initialize 2d array to 0's */
    for (j = 0; j < MAX; j++)
        a[i][j] = 0.0;
for (i = 0; i < MAX; i++)        /* put 1's along the diagonal */
    a[i][i] = 1.0;

===>

for (i = 0; i < MAX; i++)          /* initialize 2d array to 0's */
{
    for (j = 0; j < MAX; j++)
        a[i][j] = 0.0;
    a[i][i] = 1.0;                            /* put 1's along the diagonal */
}
```

#### Switch语句中根据发生频率来进行case排序

Switch 可能转化成多种不同算法的代码。其中最常见的是跳转表和比较链/树。
当switch用比较链的方式转化时，编译器会产生if-else-if的嵌套代码，
并按照顺序进行比较，匹配时就跳转到满足条件的语句执行。
所以可以对case的值依照发生的可能性进行排序，把最有可能的放在第一位，
这样可以提高性能。此外，在case中推荐使用小的连续的整数，因为在这种情况下，
所有的编译器都可以把switch 转化成跳转表。

```c
int days_in_month, short_months, normal_months, long_months;
switch (days_in_month)
{
    case 28:
    case 29:
        short_months ++;
        break;
    case 30:
        normal_months ++;
        break;
    case 31:
        long_months ++;
        break;
    default:
        cout << "month has fewer than 28 or more than 31 days" << endl;
        break;
}

===>

int days_in_month, short_months, normal_months, long_months;
switch (days_in_month)
{
    case 31:
        long_months ++;
        break;
    case 30:
        normal_months ++;
        break;
    case 28:
    case 29:
        short_months ++;
        break;
    default:
        cout << "month has fewer than 28 or more than 31 days" << endl;
        break
}
```

#### 将大的switch语句转为嵌套switch语句

当switch语句中的case标号很多时，为了减少比较的次数，
明智的做法是把大switch语句转为嵌套switch语句。
把发生频率高的case 标号放在一个switch语句中，
并且是嵌套switch语句的最外层，发生相对频率相对低的case标号放在另一个switch语句中。
比如，下面的程序段把相对发生频率低的情况放在缺省的case标号内。

```c
pMsg=ReceiveMessage();
switch (pMsg->type)
{
    case FREQUENT_MSG1:
        handleFrequentMsg();
        break;
    case FREQUENT_MSG2:
        handleFrequentMsg2();
        break;
        。。。。。。
    case FREQUENT_MSGn:
            handleFrequentMsgn();
            break;
    default:                     //嵌套部分用来处理不经常发生的消息
            switch (pMsg->type)
            {
                case INFREQUENT_MSG1:
                    handleInfrequentMsg1();
                    break;
                case INFREQUENT_MSG2:
                    handleInfrequentMsg2();
                    break;
                    。。。。。。
                case INFREQUENT_MSGm:
                        handleInfrequentMsgm();
                        break;
            }
}
```

如果switch中每一种情况下都有很多的工作要做，
那么把整个switch语句用一个`指向函数指针的表`来替换会更加有效，
比如下面的switch语句，有三种情况：

```c
enum MsgType{Msg1， Msg2， Msg3}
switch (ReceiveMessage() {
    case Msg1;
    ...
    case Msg2;
    ...
    case Msg3;
    ...
}
```
为了提高执行速度，用下面这段代码来替换这个上面的switch语句。

```c
/*准备工作*/
int handleMsg1(void);
int handleMsg2(void);
int handleMsg3(void);

/*创建一个函数指针数组*/
int (*MsgFunction [])()={handleMsg1， handleMsg2， handleMsg3};

/*用下面这行更有效的代码来替换switch语句*/
status = MsgFunction[ReceiveMessage()]();
```

#### 循环转置

有些机器对JNZ(为0转移)有特别的指令处理，速度非常快，
如果你的循环对方向不敏感，可以由大向小循环。

```c
for (i = 1; i <= MAX; i++)
{
    ...
}

===>

i = MAX+1;
while (--i)
{
    ...
}
```

不过千万注意，如果指针操作使用了i值，
这种方法可能引起指针越界的严重错误(i = MAX+1;)。
当然你可以通过对i做加减运算来纠正，但是这样就起不到加速的作用

#### 公用代码块

一些公用处理模块，为了满足各种不同的调用需要，往往在内部采用了大量的if-then-else结构，
这样很不好，判断语句如果太复杂，会消耗大量的时间的，
应该尽量减少公用代码块的使用。(任何情况下，空间优化和时间优化都是对立的--东楼)。
当然，如果仅仅是一个(3==x)之类的简单判断，适当使用一下，也还是允许的。
记住，优化永远是追求一种平衡，而不是走极端。

#### 提升循环的性能

提升循环的性能，减少多余的常量计算非常有用（比如，不随循环变化的计算）。

```c
不好的代码(在for()中包含不变的if())：
for( i 。。。  )
{
    if( CONSTANT0  )
    {
        DoWork0( i  )； // 假设这里不改变CONSTANT0的值
    }
    else
    {
        DoWork1( i  )； // 假设这里不改变CONSTANT0的值
    }
}

===>

if( CONSTANT0  )
{
    for( i 。。。  )
    {
        DoWork0( i  )；
    }
}
else
{
    for( i 。。。  )
    {
        DoWork1( i  )；
    }
}
```

如果已经知道if()的值，这样可以避免重复计算。虽然不好的代码中的分支可以简单地预测，
但是由于推荐的代码在进入循环前分支已经确定，就可以减少对分支预测的依赖。

#### 选择好的无限循环

在编程中，我们常常需要用到无限循环，常用的两种方法是while (1) 和 for (；；)。
这两种方法效果完全一样，但那一种更好呢？然我们看看它们编译后的

```txt
while (1);

===>

mov eax，1
test eax，eax
je foo+23h
jmp foo+18h

for (;;);

===>

jmp foo+23h

```
显然，for (;;)指令少，不占用寄存器，而且没有判断、跳转，比while (1)好。

#### 循环不变计算

对于一些不需要循环变量参加运算的计算任务可以把它们放到循环外面，
现在许多编译器还是能自己干这件事，不过对于中间使用了变量的算式它们就不敢动了，
所以很多情况下你还得自己干。对于那些在循环中调用的函数，凡是没必要执行多次的操作通通提出来，
放到一个init函数里，循环前调用。另外尽量减少喂食次数，没必要的话尽量不给它传参，
需要循环变量的话让它自己建立一个静态循环变量自己累加，速度会快一点。
还有就是结构体访问，东楼的经验，凡是在循环里对一个结构体的两个以上的元素执行了访问，
就有必要建立中间变量了(结构这样，那C++的对象呢?想想看)。

```c
total =
    a->b->c[4]->aardvark +
    a->b->c[4]->baboon +
    a->b->c[4]->cheetah +
    a->b->c[4]->dog;

===>

struct animals * temp = a->b->c[4];

total =
    temp->aardvark +
    temp->baboon +
    temp->cheetah +
    temp->dog;
```

一些老的C语言编译器不做`聚合优化`，而符合ANSI规范的新的编译器可以自动完成这个优化，看例子:

```c
float a， b， c， d， f， g;
。。。
a = b / c * d;
f = b * g / c;

===>

float a， b， c， d， f， g;
。。。
a = b / c * d;
f = b / c * g;
```

如果这么写的话，一个符合ANSI规范的新的编译器可以只计算b/c一次，
然后将结果代入第二个式子，节约了一次除法运算。

## 函数优化

### inline函数

在C++中，关键字Inline可以被加入到任何函数的声明中。
这个关键字请求编译器用函数内部的代码替换所有对于指出的函数的调用。
这样做在两个方面快于函数调用：第一，省去了调用指令需要的执行时间；
第二，省去了传递变元和传递过程需要的时间。但是使用这种方法在优化程序速度的同时，
程序长度变大了，因此需要更多的ROM。
使用这种优化在Inline函数频繁调用并且只包含几行代码的时候是最有效的。

### 不定义不使用的返回值

函数定义并不知道函数返回值是否被使用，假如返回值从来不会被用到，应该使用void来明确声明函数不返回任何值。

### 减少函数调用参数

使用全局变量比函数传递参数更加有效率。这样做去除了函数调用参数入栈和函数完成后参数出栈所需要的时间。
然而决定使用全局变量会影响程序的模块化和重入，故要慎重使用。

### 所有函数都应该有原型定义

一般来说，所有函数都应该有原型定义。原型定义可以传达给编译器更多的可能用于优化的信息。

### 尽可能使用常量(const)

尽可能使用常量(const)。C++ 标准规定，如果一个const声明的对象的地址不被获取，
允许编译器不对它分配储存空间。这样可以使代码更有效率，而且可以生成更好的代码。

### 把本地函数声明为静态的(static)

如果一个函数只在实现它的文件中被使用，把它声明为静态的(static)以强制使用内部连接。
否则，默认的情况下会把函数定义为外部连接。这样可能会影响某些编译器的优化——比如，自动内联。

### 采用递归

与LISP之类的语言不同，C语言一开始就病态地喜欢用重复代码循环，许多C程序员都是除非算法要求，
坚决不用递归。事实上，C编译器们对优化递归调用一点都不反感，相反，它们还很喜欢干这件事。
只有在递归函数需要传递大量参数，可能造成瓶颈的时候，才应该使用循环代码，其他时候，
还是用递归好些。



